第0章 一些你可能正感到迷惑的问题
0.1 操作系统是什么
0.2 你想研究到什么程度
0.3 写操作系统，哪些需要我来做
0.4 软件是如何访问硬件的
0.5 应用程序是什么，和操作系统是如何配合到一起的
0.6 为什么称为“陷入”内核
0.7 内存访问为什么要分段
0.8 代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗
0.9 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别
0.10 什么是段重叠
0.11 什么是平坦模型
0.12 cs、ds这类sreg段寄存器，位宽是多少
0.13 什么是工程，什么是协议
0.14 为什么Linux系统下的应用程序不能在Windows系统下运行
0.15 局部变量和函数参数为什么要放在栈中
0.16 为什么说汇编语言比C语言快
0.17 先有的语言，还是先有的编译器，第1个编译器是怎么产生的
0.18 编译型程序与解释型程序的区别
0.19 什么是大端字节序、小端字节序
0.20 BIOS中断、DOS中断、Linux中断的区别
0.21 Section和Segment的区别
0.22 什么是魔数
0.23 操作系统是如何识别文件系统的
0.24 如何控制CPU的下一条指令
0.25 指令集、体系结构、微架构、编程语言
0.26 库函数是用户进程与内核的桥梁
0.27 转义字符与ASCII码
0.28 MBR、EBR、DBR和OBR各是什么

第1章 部署工作环境
1.1 工欲善其事，必先利其器
1.2 我们需要哪些编译器
1.3 操作系统的宿主环境
1.4 配置bochs
1.5 运行bochs
第2章 编写MBR主引导记录，让我们开始掌权
2.1 计算机的启动过程
2.2 软件接力第一棒，BIOS
2.3 让MBR先飞一会儿
第3章 完善MBR
3.1 地址、section、vstart浅尝辄止
3.2 CPU的实模式
3.3 让我们直接对显示器说点什么吧
3.4 bochs调试方法
3.5 硬盘介绍
3.6 让MBR使用硬盘
第4章 保护模式入门
4.1 保护模式概述
4.2 初见保护模式
4.3 全局描述符表
4.4 处理器微架构简介
4.5 使用远跳转指令清空流水线，更新段描述符缓冲寄存器
4.6 保护模式之内存段的保护
A第5章 保护模式进阶，向内核迈进
5.1 获取物理内存容量
5.2 启用内存分页机制，畅游虚拟空间
5.3 加载内核
5.4 特权级深入浅出
第6章 完善内核
6.1 函数调用约定简介
6.2 汇编语言和C语言混合编程
6.3 实现自己的打印函数
6.4 内联汇编
第7章 中断
7.1 中断是什么，为什么要有中断
7.2 操作系统是中断驱动的
7.3 中断分类
7.4 中断描述符表
7.5 可编程中断控制器8259A
7.6 编写中断处理程序
7.7 可编程计数器/定时器8253简介
7.8 提高时钟中断的频率，让中断来得更猛烈一些
第8章 内存管理系统
8.1 makefile简介
8.2 实现assert断言
8.3 实现字符串操作函数
8.4 位图bitmap及其函数的实现
8.5 内存管理系统
第9章 线程
9.1 实现内核线程
9.2 在内核空间实现线程
9.3 核心数据结构，双向链表
9.4 多线程调度
第10章 输入输出系统
10.1 同步机制——锁
10.2 用锁实现终端输出
10.3 从键盘获取输入
10.4 编写键盘驱动
10.5 环形输入缓冲区
第11章 用户进程
11.1 为什么要有任务状态段TSS
11.2 定义并初始化TSS
11.3 实现用户进程
第12章 进一步完善内核
12.1 Linux系统调用浅析
12.2 系统调用的实现
12.3 让用户进程“说话”
12.4 完善堆内存管理
第13章 编写硬盘驱动程序
13.1 硬盘及分区表
13.2 编写硬盘驱动程序
第14章 文件系统
14.1 文件系统概念简介
14.2 创建文件系统
14.3 文件描述符简介
14.4 文件操作相关的基础函数
14.5 创建文件
14.6 文件的打开与关闭
14.7 实现文件写入
14.8 读取文件
14.9 实现文件读写指针定位功能
14.10 实现文件删除功能
14.11 创建目录
14.12 遍历目录
14.13 删除目录
14.14 任务的工作目录
14.15 获得文件属性
第15章 系统交互
15.1 fork的原理与实现
15.2 添加read系统调用，获取键盘输入
15.3 添加putchar、clear系统调用
15.4 实现一个简单的shell
15.5 加载用户进程
15.6 实现系统调用wait和exit
15.7 管道
参考文献