## 访问外部硬件有两个方式
1. 将某个外设的内存映射到一定范围的地址空间中，CPU 通过地址总线访问该内存区域时会落到外设
的内存中，这种映射让CPU 访问外设的内存就如同访问主板上的物理内存一样。比如显卡，显存被
映射到主机物理内存上的低端1MB 的`0xB8000～0xBFFFF`。往这片内存上写字节便是往屏幕上打印内容。

2. 通过IO 接口与CPU 通信，IO 接口上面有一些寄存器，访问IO 接口本质上就是
访问这些寄存器，这些寄存器就是常说的端口


## 内存访问为什么要分段
两个编译出来地址相同的程序没法同时运行
分段用来解决了这一问题，让CPU 采用“段基址+段内偏移地址”的方式来访问任意内存


## 大端字节序 vs 小端字节序
这两种字节序的优势。
（1）小端：因为低位在低字节，强制转换数据型时不需要再调整字节了。
（2）大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字
节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负。

experiment : 0x12345678 在内存中是怎样存储的
```
# 在内存的0x7c00 处插入断点 0x7c00 是BIOS 把mbr 加载到内存后会跳转过去的地址
b 0x7c00           

# 显示物理内存0x200000 开始处的4 个字节，可见其为00、00、00、00，
# 地址是从左到右逐渐升高的，其中每一对00 就占用1 个字节，它们的值都是0。
xp/4 0x200000     

# 在该地址处写入0x12345678
setpmem 0x200000 4 0x12345678     

# 再看内存地址0x200000 处的内容，由内存低地址到高地址，依次变成了0x78、0x56、0x34、0x12
xp/4 0x200000     

```

网络字节序就是大端字节序，所以在 x86 架构上的程序在发送网络数据时，要转换字节顺序


## BIOS 中断、DOS 中断、Linux 中断的区别

BIOS 和DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt
Vector Table，IVT）中的。它们都是通过软中断指令int 中断号来调用的。

中断向量表中的每个中断向量大小是4 字节。这4 字节描述了一个中断处理例程（程序）的段基址和
段内偏移地址。因为中断向量表的长度为1024 字节，故该表最多容纳256 个中断向量处理程序。计算机
启动之初，中断向量表中的中断例程是由BIOS 建立的，它从物理内存地址0x0000 处初始化并在中断向
量表中添加各种处理例程。

Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，
取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）

在实模式下执行int 指令，会自动去访问中断向量表。在保护模式下执行int 指令，则会自动访问中断描述符表。

